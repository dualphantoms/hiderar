#define _CRT_SECURE_NO_DEPRECATE
#include <stdio.h>
#include <iostream>
#include "filesss.h"

using namespace std;
using namespace filesss;

// An unsigned char can store 1 Bytes (8bits) of data (0-255)
typedef unsigned char BYTE;


int main(int argc, char* argv[])
{

	BYTE *fileBuf;			// Pointer to our buffered data
	FILE *file = NULL;		// File pointer

							// Open the file in binary mode using the "rb" format string
							// This also checks if the file exists and/or can be opened for reading correctly

	std::cout << "Command Line : ";
	for (int i = 0; i < argc; i++) {
		std::cout << argv[i] << ' ';
	}
	std::cout << std::endl;

	if (argc == 1) {
		std::cerr << "\n*** Insufficient number of arguments ***\n";
		std::cerr << "Usage: " << argv[0] << " fileName \n";
		return 1;
	}
	else if (argc != 2) {
		std::cerr << "\n*** Too many arguments ***\n";
		std::cerr << "Usage: " << argv[0] << " fileName \n";
		return 2;
	}

	fileIn jpgfile(argv[1]);
	//fileIn rarfile(argv[2]);

	cout << jpgfile.getFileSize() << endl;


	//if ((file = fopen(jpgpath, "rb")) == NULL)
	//	cout << "Could not open specified file" << endl;
	//else
	//	cout << "File opened successfully" << endl;

	//// Get the size of the file in bytes
	////long fileSize = fileIn::getFileSize(file);

	//// Allocate space in the buffer for the whole file
	//fileBuf = new BYTE[fileSize];

	// Read the file in to the buffer
	//fread(fileBuf, fileSize, 1, file);

	// Now that we have the entire file buffered, we can take a look at some binary infomation
	// Lets take a look in hexadecimal
	//for (int i = 0; i < fileSize; i++)
	//	printf("%X ", fileBuf[i]);

	cin.get();
	delete[]fileBuf;
	fclose(file);   // Almost forgot this 
	return 0;
}